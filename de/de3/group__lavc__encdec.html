<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>World of Might and Magic: send/receive encoding and decoding API overview</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">World of Might and Magic
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Open reimplementation of Might and Magic 6 7 8 game engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Поиск');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Поиск');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/de3/group__lavc__encdec.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">send/receive encoding and decoding API overview<div class="ingroups"><a class="el" href="../../d5/de3/group__libavc.html">libavcodec</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a>/avcodec_receive_frame()/avcodec_send_frame()/ <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a> functions provide an encode/decode API, which decouples input and output.  
<a href="#details">Подробнее...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Граф связей класса send/receive encoding and decoding API overview:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../de/de3/group__lavc__encdec.svg" width="320" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<p>The <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a>/avcodec_receive_frame()/avcodec_send_frame()/ <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a> functions provide an encode/decode API, which decouples input and output. </p>
<p>The API is very similar for encoding/decoding and audio/video, and works as follows:</p><ul>
<li>Set up and open the <a class="el" href="../../de/d1f/struct_a_v_codec_context.html">AVCodecContext</a> as usual.</li>
<li>Send valid input:<ul>
<li>For decoding, call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> to give the decoder raw compressed data in an <a class="el" href="../../d4/d31/struct_a_v_packet.html">AVPacket</a>.</li>
<li>For encoding, call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga9395cb802a5febf1f00df31497779169">avcodec_send_frame()</a> to give the encoder an <a class="el" href="../../d6/d03/struct_a_v_frame.html">AVFrame</a> containing uncompressed audio or video. In both cases, it is recommended that AVPackets and AVFrames are refcounted, or libavcodec might have to copy the input data. (libavformat always returns refcounted AVPackets, and <a class="el" href="../../d5/de8/group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb">av_frame_get_buffer()</a> allocates refcounted AVFrames.)</li>
</ul>
</li>
<li>Receive output in a loop. Periodically call one of the avcodec_receive_*() functions and process their output:<ul>
<li>For decoding, call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c">avcodec_receive_frame()</a>. On success, it will return an <a class="el" href="../../d6/d03/struct_a_v_frame.html">AVFrame</a> containing uncompressed audio or video data.</li>
<li>For encoding, call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a>. On success, it will return an <a class="el" href="../../d4/d31/struct_a_v_packet.html">AVPacket</a> with a compressed frame. Repeat this call until it returns AVERROR(EAGAIN) or an error. The AVERROR(EAGAIN) return value means that new input data is required to return new output. In this case, continue with sending input. For each input frame/packet, the codec will typically return 1 output frame/packet, but it can also be 0 or more than 1.</li>
</ul>
</li>
</ul>
<p>At the beginning of decoding or encoding, the codec might accept multiple input frames/packets without returning a frame, until its internal buffers are filled. This situation is handled transparently if you follow the steps outlined above.</p>
<p>In theory, sending input can result in EAGAIN - this should happen only if not all output was received. You can use this to structure alternative decode or encode loops other than the one suggested above. For example, you could try sending new input on each iteration, and try to receive output if that returns EAGAIN.</p>
<p>End of stream situations. These require "flushing" (aka draining) the codec, as the codec might buffer multiple frames or packets internally for performance or out of necessity (consider B-frames). This is handled as follows:</p><ul>
<li>Instead of valid input, send NULL to the <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> (decoding) or <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga9395cb802a5febf1f00df31497779169">avcodec_send_frame()</a> (encoding) functions. This will enter draining mode.</li>
<li>Call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c">avcodec_receive_frame()</a> (decoding) or <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a> (encoding) in a loop until AVERROR_EOF is returned. The functions will not return AVERROR(EAGAIN), unless you forgot to enter draining mode.</li>
<li>Before decoding can be resumed again, the codec has to be reset with <a class="el" href="../../d2/dcf/group__lavc__misc.html#gaf60b0e076f822abcb2700eb601d352a6">avcodec_flush_buffers()</a>.</li>
</ul>
<p>Using the API as outlined above is highly recommended. But it is also possible to call functions outside of this rigid schema. For example, you can call <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> repeatedly without calling <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c">avcodec_receive_frame()</a>. In this case, <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> will succeed until the codec's internal buffer has been filled up (which is typically of size 1 per output frame, after initial input), and then reject input with AVERROR(EAGAIN). Once it starts rejecting input, you have no choice but to read at least some output.</p>
<p>Not all codecs will follow a rigid and predictable dataflow; the only guarantee is that an AVERROR(EAGAIN) return value on a send/receive call on one end implies that a receive/send call on the other end will succeed, or at least will not fail with AVERROR(EAGAIN). In general, no codec will permit unlimited buffering of input or output.</p>
<p>This API replaces the following legacy functions:</p><ul>
<li><a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga3ac51525b7ad8bca4ced9f3446e96532">avcodec_decode_video2()</a> and <a class="el" href="../../d0/d0c/group__lavc__decoding.html#gaaa1fbe477c04455cdc7a994090100db4">avcodec_decode_audio4()</a>: Use <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> to feed input to the decoder, then use <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga11e6542c4e66d3028668788a1a74217c">avcodec_receive_frame()</a> to receive decoded frames after each packet. Unlike with the old video decoding API, multiple frames might result from a packet. For audio, splitting the input packet into frames by partially decoding packets becomes transparent to the API user. You never need to feed an <a class="el" href="../../d4/d31/struct_a_v_packet.html">AVPacket</a> to the API twice (unless it is rejected with AVERROR(EAGAIN) - then no data was read from the packet). Additionally, sending a flush/draining packet is required only once.</li>
<li><a class="el" href="../../db/d91/group__lavc__encoding.html#ga2c08a4729f72f9bdac41b5533c4f2642">avcodec_encode_video2()</a>/avcodec_encode_audio2(): Use <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga9395cb802a5febf1f00df31497779169">avcodec_send_frame()</a> to feed input to the encoder, then use <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a> to receive encoded packets. Providing user-allocated buffers for <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga5b8eff59cf259747cf0b31563e38ded6">avcodec_receive_packet()</a> is not possible.</li>
<li>The new API does not handle subtitles yet.</li>
</ul>
<p>Mixing new and old function calls on the same <a class="el" href="../../de/d1f/struct_a_v_codec_context.html">AVCodecContext</a> is not allowed, and will result in undefined behavior.</p>
<p>Some codecs might require using the new API; using the old API will return an error when calling it. All codecs support the new API.</p>
<p>A codec is not allowed to return AVERROR(EAGAIN) for both sending and receiving. This would be an invalid state, which could put the codec user into an endless loop. The API has no concept of time either: it cannot happen that trying to do <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> results in AVERROR(EAGAIN), but a repeated call 1 second later accepts the packet (with no other receive/flush API calls involved). The API is a strict state machine, and the passage of time is not supposed to influence it. Some timing-dependent behavior might still be deemed acceptable in certain cases. But it must never result in both send/receive returning EAGAIN at the same time at any point. It must also absolutely be avoided that the current state is "unstable" and can "flip-flop" between the send/receive APIs allowing progress. For example, it's not allowed that the codec randomly decides that it actually wants to consume a packet now instead of returning a frame, after it just returned AVERROR(EAGAIN) on an <a class="el" href="../../d0/d0c/group__lavc__decoding.html#ga58bc4bf1e0ac59e27362597e467efff3">avcodec_send_packet()</a> call. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Документация по World of Might and Magic. Последние изменения: Вт 7 Апр 2020 22:04:23. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
